(function ticTacToe () { //Setting up all the JavaScript to be a module (Surprising makes it a lot harder to debug with it on).
  const boxes = $('.box'); //Variable set up to select all the boxes with the class.
  let boxValue = ['0', '1', '2', '3', '4', '5', '6', '7', '8']; //Setting up an array to capture all the X's and O's.
  let player1 = {isTurn: true}; //An object to store player turn as a boolean.
  let player2 = {isTurn: false}; //An object to store player turn as a boolean.
  let player1Val = 0; //Variable to set up the players' values with 0 = O.
  let player2Val = 1; //Variable to set up the players' values with 1 = X.


  //Function to start off the game by hiding all unnecessary html divs.
  function start () {
    $('#start').show();
    $('#board').hide();
    $('#finish').hide();
  }


  //Function to loop through all the elements of the boxes list and dynamically add IDs to each from 1-9.
  function setID () {
    for (let i = 0; i < boxes.length; i++) {
      $(boxes[i]).attr('id', [i]);
    }
  }


  //Function used to set player 1 as active player when it is player 1's turn.
  function setActiveP1 () {
    $('#player2').removeClass('active');
    $('#player1').addClass('active');
    player1.isTurn = true;
  }


  //Function used to set player 2 as active player when it is player 2's turn.
  function setActiveP2 () {
    $('#player1').removeClass('active');
    $('#player2').addClass('active');
    player1.isTurn = false;
  }


  //Function used to set up input values as names for each player.
  function setNames () {
    let player1Name = $('input#name1').val();
    let player2Name = $('input#name2').val();
    player1.name = player1Name;
    player2.name = player2Name;
  }


  //Function used to insert the names onto the ticTacToe board.
  function insertNames () {
    $('.in-game-name').remove();
    $('li#player1').append('<p class="in-game-name">' + player1.name + '</p>');
    $('li#player2').append('<p class="in-game-name">' + player2.name + '</p>');
  }


  //Function used in minimax function in order to get all the empty boxes from boxValue/newBoard arrays and put them into an array.
  function emptyBoxes (board) {
      return board.filter(val => val !== 1 && val !== 0);
  }


  //Function to return a string index value for best possible move generated by minimax function.
  function bestSpot () {
    return minimax(boxValue, player2Val).index;
  }


  //Recursive function that iterates through a board, generating all emptyBoxes by checking for non-numerical values.
  //Function breaks infinite loop when a win is sensed via the checkWin function returning true, false, or null.
  //This requires us to set up a moves array,
  //    and then within the loop creating a move object that gets pushed into the array and refreshed with every iteration of the loop.
  //It does this by seeing how many empty spots there are on the board,
  //    and testing each spot by placing an O and a X alternatingly to create possible gamestates.
  //It then takes these possible gamestates and feeds it back into the minimax function recursively,
  //    ending upon a winning or losing gamestate.
  //It pushes the score as well as the moves it took to get there into a dictionary first and stores the values in move.index/move.score.
  //It then uses stored score to compare what it should be doing for each player.
  //    For player1, which is not the computer, it wants to achieve the lowest score possible.
  //        This is done by checking the value against 10000, and keeping the value that is the lowest.
  //    For player2, which is the computer, it wants to achieve the highest possible score.
  //        This is done by checking the value against -10000, and keeping the value that is the highest.
  //The function ends with returning the bestMove to the Moves array.
  function minimax(newBoard, player) {
  	let availSpots = emptyBoxes(newBoard);
  	if (checkWin(newBoard)) {
  		return {score: -10};
  	} else if (checkWin(newBoard) === false) {
  		return {score: 10};
  	} else if (checkWin(newBoard) === null) {
  		return {score: 0};
  	}
  	let moves = [];
  	for (let i = 0; i < availSpots.length; i++) {
  		let move = {};
  		move.index = newBoard[parseInt(availSpots[i])];
  		newBoard[parseInt(availSpots[i])] = player;
  		if (player == player2Val) {
  			let result = minimax(newBoard, player1Val);
  			move.score = result.score;
  		} else {
  			let result = minimax(newBoard, player2Val);
  			move.score = result.score;
  		}
  		newBoard[availSpots[i]] = move.index;
  		moves.push(move);
  	}
  	let bestMove;
  	if(player === player2Val) {
  		let bestScore = -10000;
  		for(let i = 0; i < moves.length; i++) {
  			if (moves[i].score > bestScore) {
  				bestScore = moves[i].score;
  				bestMove = i;
  			}
  		}
  	} else {
  		let bestScore = 10000;
  		for(let i = 0; i < moves.length; i++) {
  			if (moves[i].score < bestScore) {
  				bestScore = moves[i].score;
  				bestMove = i;
  			}
  		}
  	}
  	return moves[bestMove];
  }


  //Function that checks for a win based on 3 O's in a row (0 + 0 + 0) and for a win based on 3 1's in a row (1 + 1 + 1).
  //The function also uses a filter to check for any non-numerical values to see if there are any empty spaces on the board left.
  //    If there are none left, and the game has no winners, it results in a tie.
  //The function returns a true value for a player 1 win, returning a false value for player 2 win, and a null value for tie.
  function checkWin (board) {
    let value = board.filter(values => values !== 1 && values !== 0);
    if (board[0] + board[1] + board[2] === 0
      || board[3] + board[4] + board[5] === 0
      || board[6] + board[7] + board[8] === 0
      || board[0] + board[3] + board[6] === 0
      || board[1] + board[4] + board[7] === 0
      || board[2] + board[5] + board[8] === 0
      || board[2] + board[4] + board[6] === 0
      || board[0] + board[4] + board[8] === 0)
      {
      return true;
    } else if (board[0] + board[1] + board[2] === 3
      || board[3] + board[4] + board[5] === 3
      || board[6] + board[7] + board[8] === 3
      || board[0] + board[3] + board[6] === 3
      || board[1] + board[4] + board[7] === 3
      || board[2] + board[5] + board[8] === 3
      || board[2] + board[4] + board[6] === 3
      || board[0] + board[4] + board[8] === 3)
      {
      return false;
    } else if (value.length === 0) {
      return null;
    }
  }


  //Function that takes the bestSpot function and turns the string index of bestSpot into a number.
  //Then uses that index value to iterate through the boxes and then fill them with an X.
  //Then sets turn to player 1.
  function aiFillsBox () {
    let aiBox = parseInt(bestSpot());
    $('#' + aiBox).addClass('box-filled-2 disabled');
    boxValue[aiBox] = player2Val;
    setActiveP1();
  }


  //Function used to determine what endgame screen is used once the game is over.
  function finish (num) {
    $('#start').hide();
    $('#board').hide();
    if (num === 1) {
      $('div#finish').removeClass('screen-win-two');
      $('div#finish').removeClass('screen-win-tie');
      $('div#finish').addClass('screen-win-one');
      $('p.message').text(player1.name + ' wins!');
    } else if (num === 2) {
      $('div#finish').removeClass('screen-win-one');
      $('div#finish').removeClass('screen-win-tie');
      $('div#finish').addClass('screen-win-two');
      $('p.message').text(player2.name + ' wins!');
    } else if (num === 3) {
      $('div#finish').removeClass('screen-win-one');
      $('div#finish').removeClass('screen-win-two');
      $('div#finish').addClass('screen-win-tie');
      $('p.message').text('Tie.');
    }
    $('#finish').show();
  }


  //EventListener for the new game button that serves to reset everything in the game.
  $('.button').on('click', () => {
    $('.box').removeClass('box-filled-1 box-filled-2 disabled')
    setActiveP1();
    boxValue = ['0', '1', '2', '3', '4', '5', '6', '7', '8'];
    setNames();
    insertNames();
    $('#start').hide();
    $('#board').show();
    $('#finish').hide();
  })


  //EventListener used for displaying the background of X or O depending on the hover.
  $('.box').hover((e) => {
    if(player1.isTurn) {
      $(e.target).css('background-image', 'url(img/o.svg)');
    } else {
      $(e.target).css('background-image', 'url(img/x.svg)');
    }},
    (e) => {$(e.target).css('background-image', '')
  })


  //EventListener used for clicks on the boxes in order to fill them with X's and O's accordingly.
  //Also has a conditional statement to account for the moves the computer makes, by queueing them directly after player 1.
  $('.box').on('click', (e) => {
    if(player1.isTurn) {
      $(e.target).addClass('box-filled-1 disabled');
      let arrIndex = parseInt($(e.target).attr('id'));
      boxValue[arrIndex] = player1Val;
      setActiveP2();
      if (player2.name === 'Computer' || player2.name === "computer") {
        aiFillsBox();
      }
    } else {
      $(e.target).addClass('box-filled-2 disabled');
      let arrIndex = parseInt($(e.target).attr('id'));
      boxValue[arrIndex] = player2Val;
      setActiveP1();
    }
    checkWin(boxValue);
    if (checkWin(boxValue)) {
      setTimeout(function () {finish(1)}, 400);
    } else if (checkWin(boxValue) === false) {
      setTimeout(function () {finish(2)}, 400);
    } else if (checkWin(boxValue) === null) {
      setTimeout(function () {finish(3)}, 400);
    }
  })

  //Calling all the necessary functions to start the game.
  start();
  setActiveP1();
  setID();
})();
